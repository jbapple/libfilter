\documentclass[letterpaper, 11pt]{article}

\pdfoutput=1

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{color}
\usepackage{graphicx}
\PassOptionsToPackage{hyphens}{url}\usepackage[pdftitle={Plastic cuckoo filters: growing a cuckoo filter}]{hyperref}
\usepackage{microtype}
\usepackage[strings]{underscore}
\usepackage{doi}
\usepackage{nicefrac}
\usepackage{listings}
%\usepackage{todonotes}

\newtheorem{theorem}{Theorem}

\lstset{
%    frame=tb, % draw a frame at the top and bottom of the code block
%    tabsize=2, % tab space width
%    showstringspaces=false, % don't mark spaces in strings
%    numbers=left, % display line numbers on the left
%    commentstyle=\color{green}, % comment color
%    keywordstyle=\color{blue}, % keyword color
%    stringstyle=\color{red}, % string color
    basicstyle=\small\ttfamily,
    basewidth = {.48em}
}

\DeclareMathOperator{\adj}{adj}

%\renewcommand\UrlFont{\color{blue}\rmfamily}

%% \newcommand{\reals}{\mathbb{R}}
%% \newcommand{\rats}{\mathbb{Q}}
%% \newcommand{\nats}{\mathbb{N}}
\newcommand{\ints}{\mathbb{Z}}
%% \newcommand{\cplx}{\mathbb{C}}
\newcommand{\defeq}{\;\genfrac{}{}{0pt}{2}{\text{def}}{=}\;}

%\pagestyle{empty}

% https://tex.stackexchange.com/questions/171803/change-font-size-of-the-verbatim-environment
% \newcommand{\verbatimfont}[1]{\renewcommand{\verbatim@font}{\ttfamily#1}}

%% \usepackage{etoolbox}
%% \makeatletter
%% \patchcmd{\@verbatim}
%%   {\verbatim@font}
%%   {\verbatim@font\small}
%%   {}{}
%% \makeatother


\begin{document}

\title{Plastic cuckoo filters: growing a cuckoo filter}
\author{Jim Apple \\
  jbapple@apache.org}
\maketitle
%\thispagestyle{empty}

\section{Introduction}
While there are many filter structures that support approximate membership queries on sets with a given maximum size, the question of extensible (or {\em incremental} or {\em growable}) filters is little studied.
The classic answer is to create a sequence of filters.
Even when this keeps the false positive rate low, lookup times balloon from constant to logarithmic or even linear.~\cite{psw,logarithm,consistent-cuckoo} %The Dynamic Cuckoo Filter
Later authors consider cuckoo filters in which, when the filter grows, the size of the fingerprint shrinks, thereby increasing the false positive probability.~\cite{logarithm,morton-journal,vacuum,rsqf}

In \cite{psw}, the authors introduce a structure that performs lookups in $O(1)$ while still allowing the structure to grow and keep a low false positive rate (not exceeding a threshold specified when the structure was created) all while using no more than $O(\lg \lg n + \lg (1/\varepsilon))$ words of space per element.
Section~\ref{pcf} presents `plastic cuckoo filters, a practical instantiation of this model, an outstanding challenge from \cite{psw}.

Additionally, the structure in~\cite{psw} depends on \cite{succinct}.
As noted in \cite{dysect}, dictionaries like \cite{succinct} do not directly address the problem of using low space when the dictionary is not near the maximum space it will need.
For example, as a set grows from size $x$ to $2x$ in increments of one, the dictionary in \cite{succinct} will reconstruct the entire dictionary at least once.
Furthermore, if the reconstruction increases the capacity from $y$ to $(1 + \delta)y$, $1/\lg(1+\delta)$ rebuilds will occur.
Finally, non-power-of-two sizes pose challenges for quotienting, a technique needed to reduce the space usage by up to one bit per element.~\cite{change-your-base, cleary-quotient}

Section~\ref{mpcf} presents a minimal plastic filters based on~\cite{dysect}.
This version of filter re-allocates and refills the table only once for each time the table doubles in size, but does so without increasing the capacity and space usage of the table beyond a small percentage over the size of the data contained within.

\section{Plastic cuckoo filters}
\label{pcf}
Plastic cuckoo filters (``PCFs'') are approximate membership query structures that offer the following operations:

\begin{itemize}
\item {\bf Create} initializes an empty filter with the given size
  %and false positive probability, and expected {\em growth factor}.
  %A growth factor is the maximum number of doublings the structure must be able to undergo while maintaining the given false positive probability.
\item {\bf Insert} adds a key to the filter.
  This takes $O(1)$ expected time.
  It can fail when the filter is nearly full.
\item {\bf Lookup} takes a key and returns \verb|True| if the key is in the structure and \verb|False| with probability $1-\varepsilon$ is the key is not in the structure.
  This is called a {\em membership test}.
  It takes $O(1)$ worst-case time
\item {\bf Upsize} doubles the capacity of the filter in $\Theta(n)$ time.
\end{itemize}

We use quotienting cuckoo tables (as in backyard cuckoo hashing~\cite{backyard}) to store the data in a plastic cuckoo filter.
The quotienting table uses permutation hash functions to transform the input key into two different hash values such that either can be used to reconstruct a portion of the original key.
Then the top $\lg n - O(1)$ bits are omitted from the stored values, since these are implicitly stored in the location of the bucket.
In this way, data can be moved from one sub-table to the other via key reconstruction, even without storing the key.

A slot consists of two groups of bits: one of size 8, and the other of size up to 7.
The former is called the fingerprint and the latter is called the tail.
A bucket consists of four (possibly empty) slots.
A side consists of $2^k$ buckets for some $k$ as well as a permutation on $\ints_{2^{k+8}}$.
A PCF consists of two sides and one hash function that produces a 64-bit key.
The two sides have the same number of buckets but different permutations.

A lookup begins by hashing a key with the PCF's hash function.
Then the lookup operation does the following:

\begin{enumerate}
\item Applies a permutation to the most-significant $k+8$ bits in the key.
\item Reserves the next 7 bits of the key; this will be the key's tail.
\item Using the most-significant $k$ bits in the result, selects a bucket.
(The remaining 8 bits in the permuted value are the fingerprint.)
\item Checks to see if any slot contains an identical fingerprint.
If so, checks if the slot's tail is a prefix of the key's tail.
If yes, returns \verb|True|.
Otherwise, returns \verb|False|.
\end{enumerate}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
Slot := {fingerprint: `$\ints_2^8$`, tail: `$\cup_{i \le 7} \ints_2^i$`}
Bucket := Slot`$_\bot$`[4]
Side(k) := {Bucket[2^k], Permutation: `$S_{2^{k+8}}$`}
PCF(U, k) := {Side(k)[2], HashFunction: `$U \to \ints_2^{64}$`}

LookupBucket(fingerprint, tail bucket) {
  for (slot : bucket) {
    if (slot.fingerprint == fingerprint
        && slot.tail IsPrefixOf tail) {
      return True
    }
  }
  return False
}

Lookup(input: U, pcf: PCF(U, k)) {
  hashed := pcf.HashFunction(input)
  for (side : pcf.Side[0], pcf.Side[1]) {
    permuted := side.Permutation(hashed[0, k+8))
    tail := hashed[k+8, k+15)
    bucket := side.Bucket[permuted[0, k)]
    if LookupBucket(permuted[k, k+8), tail, bucket) return True
  }
  return False
}
\end{lstlisting}
\caption{The types of a PCF and the lookup operation.
  $S_i$ is the symmetric group on $\ints_i$.
  $T_\bot$ means the type $T$ extended with the element $\bot$, indicating ``null'' or ``empty''.
  Pseudocode will not make a distinction between $\ints_2^i$ and $\ints_{2^i}$.
}
\end{figure}

The insert operation first searches for the key, and, if found, returns.
Otherwise, as in lookup operations, insert places the key's fingerprint and tail in an empty slot, if one is found.
If none is found, insert selects a slot from the bucket to {\em kick}: the data in this slot will be moved to the other side.

The kick operation first reconstructs the high order $k + 8$ bits of the key by concatenating the $k$ bits of the bucket index and the $8$ bits of the fingerprint, then applying that side's permutation in reverse to the value.
Using the same tail (this does not get permuted), kick then inserts the data into the other side using the insert algorithm described above.

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
InsertPCF(input: U, pcf: PCF(U, k)) {
  if (Lookup(input, pcf)) return
  hashed := pcf.HashFunction(input)
  InsertSide(hashed[0, k+8), hashed[k+8, k+15),
             pcf.Side[0], pcf.Side[1])
}

InsertBucket(fingerprint, tail, bucket) {
  new_slot := {fingerprint := fingerprint, tail: tail}
  for(slot : bucket) {
    if (slot == `$\bot$`) {
      slot := new_slot
      return
    }
  }
  swap(slot, RandomSlotIn(bucket))
  return slot
}

InsertSide(hashed: `$\ints_2^{k+8}$`, tail: `$\cup_{i \le 7} \ints_2^i$`,
           side: Side(k), otherSide: Side(k)) {
  permuted := side.Permutation(hashed)
  bucket := side.Bucket[permuted[0, k)]
  new_slot = InsertBucket(permuted[k, k+8), tail, bucket)
  if (new_slot == `$\bot$`) return
  Kick(side, otherSide, permuted[0, k), new_slot)
}

Kick(side: Side(k), otherSide: Side(k),
     bucket_index: `$\ints_{2^k}$`, slot: Slot) {
  permuted := Concat(bucket_index, slot.fingerprint)
  hashed := side.Permutation`$^{-1}$`(permuted)
  InsertSide(hashed, slot.tail, otherSide, side)
}
\end{lstlisting}
\caption{Pseudocode for the insert operation on PCFs}
\end{figure}

The upsize operation begins by creating a new PCF.
To transfer the data, it uses the kick algorithm, but needs an alteration, since the number of buckets is now $2^{k+1}$.
To produce a key with that many bits, first reconstructs the $k+8$ bits of the key that were used to construct the bucket index and fingerprint.
Then a bit is ``stolen'' from the tail and appended onto the end of the key.
Since the tail was taken unaltered from the key, this gives $k+9$ bits of the original key.
The new tail is now decreased in size by one.
The key and the new tail of it can now be inserted into one of the sides of the new PCF as described above.

This works as long as the tail has positive length.
If the tail has length zero, there is nothing to steal from.
Instead, two candidate keys are created from the reverse-permuted $k+8$ bits by appending a zero and a one.
It's indeterminate which one of these was in the original key, so both are inserted.

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
Steal(head: `$\ints_2^{k+8}$`, tail: `$\cup_{i \le 7}\ints_2^i$`) {
  if (|tail| == 0) {
    return Concat(head, 0), Concat(head, 1), tail
  }
  return Concat(head, tail[0]), tail[1, |tail|)
}

Upsize(pcf: PCF(U, k)) {
  result := PCF(U, k + 1)
  for (side : pcf) {
    for (bucket_index : `$\ints_{2^k}$`) {
      for (slot : side.Bucket[bucket_index]) {
        permuted := Concat(bucket_index, slot.fingerprint)
        hashed := side.Permutation`$^{-1}$`(permuted)
        stolen := Steal(hashed, slot.tail)
        if (head, tail) := stolen {
          InsertSide(head, tail, result.Side[0],
                                 result.Side[1])
        } else {
          (head0, head1, tail) := stolen
          InsertSide(head0, tail, result.Side[0],
                                  result.Side[1])
          InsertSide(head1, tail, result.Side[0],
                                  result.Side[1])
        }
      }
    }
  }
  pcf = result
}
\end{lstlisting}
\caption{Pseudocode for the upsize operation on PCFs}
\end{figure}

\subsection{Space and false positive analysis}

In \cite{psw}, the dictionary is broken up into subsequences of size $2^i$.
Each subsequence $S_i$ contains the inserted keys with insertion order number in $[2^i, 2^{i+1})$.
Only when transitioning subsequences is the steal operation performed.
However, in PCFs, transitions happen when the dictionary is near full.
This does not necessarily correspond to the sequences.
Firstly, the $i$th dictionary cannot hold $2^i$ keys, just $\alpha 2^i$, where $\alpha$ si the ``fill factor''.
Second, the dictionary is sized according to the number of entries, while the structure in \cite{psw} is sized according to the number of insertions.
These differ, as the number of entries for a sequence grows as the sequence lengthens as a result of the steals against an empty tail.

The false positive probability depends on the number of elements with different tail lengths.
Specifically, in a dictionary with $n$ elements where $p(i)$ is the number of elements with tail of length $i$, the false positive probability is less than

\[
8 n^{-1} \sum_{i \le 7} 2^{-i-8}p(i)
\]

\[
2^{-5} n^{-1} \sum_{i \le 7} 2^{-i}p(i)
\]

In any insertion sequence $I$, let $\alpha_I$ be the smallest number such that a dictionary with $\alpha_I x$ entries and capacity for $x$ entries is upsized.



\begin{theorem}
  $p(i)$
\end{theorem}~\begin{proof}
Assuming the dictionary starts with both sides having Bucket arrays of size 1, and thus having an element capacity of 8, the first $8 \alpha$ elements are inserted before any upsizing and therefore have tails of the full length, 7.
In this first phase, a candidate gets compared to at most $8 \alpha$ elements and has a $2^{-15}$ chance of collision with each, for a false positive probability (``fpp'') of less than $2^{-12}$.
Once the table has resized to having capacity 16, at most 8 of the slots are filles with tails of length 6.
The addition of at most 8 more items of length 7 makes

\[
p(i) =
\begin{cases}
8 & i = 6\\
8 & i = 7\\
0 & \text{otherwise}
\end{cases}
\]

and thus the fpp is less than $8 \cdot 16^{-1} (2^{-14}\cdot 8 + 2^{-15}\cdot 8) = 2^{-12} + 2^{-13}$.
Repeating, we get

\[
p(i) =
\begin{cases}
8 & i = 5\\
8 & i = 6\\
16 & i = 7\\
0 & \text{otherwise}
\end{cases}
\]

and thus the fpp is less than $8 \cdot 32^{-1} (2^{-13}\cdot 8 + 2^{-14}\cdot 8 + 2^{-15}\cdot 16) = 2^{-12} + 2^{-13} + 2^{-13}$.

\[
p(i) =
\begin{cases}
8 & i = 4\\
8 & i = 5\\
16 & i = 6\\
32 & i = 7\\
0 & \text{otherwise}
\end{cases}
\]

and thus the fpp is $8 \cdot 64^{-1} (2^{-12}\cdot 8 + 2^{-13}\cdot 8 + 2^{-14}\cdot 16 + 2^{-15}\cdot 32) = 2^{-12} + 2^{-13} + 2^{-13} + 2^{-13}$.

This pattern repeats until and including

\[
p(i) =
\begin{cases}
8 & i = 0\\
2^{2+i} & \text{otherwise}
\end{cases}
\]

when $n = 2^{10}$ after inserting $2^10$.

so the fpp is less than $2^{-12} + 6 \cdot 2^{-13}$

After that, the next $p(i)$ is

\[
p(i) =
\begin{cases}
3 \cdot 2^3 & i = 0\\
2^{10} - 8 & i = 7 \\
2^{3+i} & \text{otherwise}
\end{cases}
\]

with $n = 2^{11} - 2^4 + 3 \cdot ^3$ after inserting $2^11$

and then

\[
p(i) =
\begin{cases}
4 \cdot 2^4 & i = 0\\
2^{4+i} & \text{otherwise}
\end{cases}
\]

with $n = 2^{12} - 2^5 + 4 \cdot 2^4$


following the pattern

\[
p(i) =
\begin{cases}
j \cdot 2^j & i = 0\\
2^{j+i} & \text{otherwise}
\end{cases}
\]

when $n = j \cdot 2^j - 2^{j+1} + 2^{8+j}$ after inserting

In this case, the false positive probability is 

\[
2^{-5} \cdot (j \cdot 2^j - 2^{j+1} + 2^{8+j})^{-1}(j \cdot 2^j + 2^{-1}2^{j+1} + 2^{-2}2^{j+2} \dots)
\]

\[
2^{-5} \cdot (j \cdot 2^j - 2^{j+1} + 2^{8+j})^{-1}(j \cdot 2^j + 7\cdot2^j)
\]

\[
2^{-5} \cdot (2^j(j - 2 + 2^8))^{-1}2^j(j + 7)
\]

\[
2^{-5} (j - 2 + 2^8)^{-1}(j + 7)
\]

\[
\frac{j+7}{2^5 (j - 2 + 2^8)}
\]

\end{proof}

That is only approximated in PCFs, as the 

The calculations of how many slots the accumulation of these doublings produces is the key calculation in the space consumption analysis in~\cite{psw}.
That is crucial as well for the false positive rate
For the concrete setting here, if the dictionary starts with $k = 0$ (each side having size 1 bucket), then after $m$ upsizes, if $m < 7$, $2^{m+2}(1 - \delta)$ keys have been inserted and the same number are in the dictionary.
Half of the tails have length seven, a quarter have length six, and so on.
The false positive probability is $2^{m+2}(1 - \delta) \cdot 2^{-m-8}(m \cdot 2^{-8}) = m(1-\delta)2^{-14}$, which is between $6.1E-5$ and $4.2E-4$.
TODO: experimentally different. Make graph.
%% check to see if the tail in that slot is a prefix of the 

%% To look up a key

%% Plastic cuckoo filters are based on this filter, but additionally add a value to each key.
%% The value is the next $\lg d$ bits of the key, where $d$ is the growth factor.



%% Plastic cuckoo filters are based on a type of bloomier filter.
%% A bloomier filter is an AMQ supporting lookups, not just membership queries.
%% Given a domain and range $D$ and $R$ where $D \subset U$ and $M$ is a map from $D$ to $R$, a query for $x$ in a bloomier filter for $M$ returns $M(x)$ if $x \in D$ and $\bot$ with probability $1-\varepsilon$ when $x \in U \backslash D$, and otherwise returns an arbitrary value in $R$.

%% Next we will form a quotienting cuckoo map.
%% A quotienting cuckoo map has a domain of $\ints_d$ and a range of $\ints_r$.
%% A standard cuckoo map would use $d + r$ bits per unit of capacity.
%% A quotienting cuckoo table uses $d + r + \lg b -  \lg m $ where $m$ is the capacity of the table and $b$ is the size of the bucket.


%% In an elastic filter, the permuted key has length $\lg \nicefrac{1}{\varepsilon} + \lg m - \lg b$ while the range consists of all sequences of bits of length less than $\lg\lg \nicefrac{U}{n} + O(1)$.
%% When the table is nearly full, meaning that further additions would likely fail, the size is doubled.
%% This increases the size of the unstored bits by 1, so the number of stored bits would be smaller, as well.
%% Instead of letting that happen, a bit is ``stolen'' from the range of sequences of bits.

%% This shortens the value in the range, but the range stays the same.
%% If there are no bits to steal becuase the value is the empty string, {\em two} new values are generated to insert into the new, larger table: one with a one appended to the stored bits, one with a zero.
%% This follows directly from \cite{psw}.

\section{Minimal plastic cuckoo filter}
\label{mpcf}

The previous structure suffers from a step-function space usage:
at each point, the structure has a size which is a power of two, sometimes allocating much more space than is needed.
To address this, this section describes a similar structure using DySECT to reduce the space usage to only what is needed.~\cite{dysect}

In a minimal plastic cuckoo filter (``MPCF''), each slot has a fingerprint of size 7 or 8 and a tail of size up to 6.
A bucket consists of four slots.
A level consists of two tables of the same size, each with $2^k$ buckets for some $k$.
The table consists of four permutations, one hash function, $32$ levels, and one cursor pointing to some index in the set of levels.
The maximum and minimum $k$ across all levels differ by at most 1.
Levels at location less than the cursor have the larger size.
If all levels have the same size, the cursor must be 0.

The permutations are grouped by side, two for each.
The permutations are on values with length $k + 12$ and $k + 13$, where $2^k$ is the size of the smallest table, in buckets.

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
MSlot := {fingerprint: `$\ints_2^7 \cup \ints_2^8$`, tail: `$\cup_{i \le 6} \ints_2^i$`}
MBucket := MSlot$_\bot$[4]
Level(k) := MBucket[2][2^k] `$\cup$` MBucket[2][2^(k+1)]
Permutation(k) := `$S_{2^{k+12}} \times S_{2^{k+13}}$`
MPCF(U, k) := {cursor: `$\ints_{32}$`,
               Level(k)[32],
               Permutation(k)[2],
               HashFunction: `$U \to \ints_2^{64}$`}

\end{lstlisting}
\caption{The types of an MPCF.
``$\times$'' should be interpreted as the Cartesian product.
}
\end{figure}

If there are larger and smaller levels, then every slot in the larger levels has a fingerprint of size 7, not 8.
This is because the implicitly-stored part of the key is one-bit longer in the larger levels.

In an MPCF, upsize only increases the size of one of the levels, not the whole structure.
As a result, the capacity of the filter tracks more closely the number of entries in the table.

To lookup a value in an MPCF, apply each of the four permutations to the hashed key.
For the permutations on $k + 13$ bits, the first five bits indicate the level, the next $k$ or $k+1$ indicate the bucket, and the remaining 7 or 8 bits are the fingerprint.
Lookup proceeds as it does in the PCF case, by checking if fingerprints match and if the stored tail is a prefix of the tail of the key being looked up.
For the permutations on $k + 12$ bits, the first five bits again indicate the level.
If the level has tables with $2^{k+1}$ buckets, the permuted key is ignored; to do otherwise would leave only $k+12 - 5 - (k+1) = 6$ bits for the fingerprint, which is not possible.
Otherwise, the level has tables with $2^k$ buckets, and we can proceed as in the $k+13$ case.


Upsize only increases the size of one level.
After 31 upsizes, the next one makes all of the levels the same size.
At that point, two new permutations must be initialized to handle new longer key prefixes.

During a kick operation, a slot may move between levels with differently-sized arrays of buckets.
This poses no problem when the fingerprint has size 8, but when the fingerprint has size 7 and the level moved from has a bucket array of size $2^k$ and the level moved to has a bucket array of size $2^{k+1}$,  there are not enough bits in the fingerprint.
As above, we steal bits from the tail, and, as above, if there are no bits to steal, two new key prefixes are created and inserted, as one of them must be the prefix of the original key.

%% InsertMPCF(input: U, mpcf: MPCF(U, k)) {
%%   if (Lookup(input, mpcf)) return
%%   hashed := mpcf.HashFunction(input)
%%   InsertSide(hashed[0, k+8), hashed[k+8, k+15),
%%              mpcf.Side[0], mpcf.Side[1])
%% }


%% The primary complexity in combining DySECT and the unnamed structure from \cite{psw} is that different levels of the structure have different sizes, and so the portion of the hashed value that is implicitly stored in the location is different.
%% This is why the fingerprint size can vary across slots.
%% One restriction is that, 



%% To address this, in a minimal plastic cuckoo filter, the key is permited to have a lower size.
%% In larger levels, the key has length $L + z + \lg \nicefrac{1}{\varepsilon}$.
%% In smaller levels, the key may also have length one less than that.
%% Since longer keys can be stored in longer of shorter levels, the values associated with keys in the lnger levels are shorter than the values associated with long keys in the shorter levels.

%% When moving keys between levels, keys may sometime move from shorter to longer keys when moving from a short level to a long level.
%% When this occurs, a bit is stolen from the tail, as described above for plastic filters.
%% This means that sometimes a single key turns into two, as above.
%% During the transition from all-small levels to all-large levels, each key will have a bit moved to it from the value exactly once, since when keys move from long levels to short levels, they can keep the same length.

%% In a DySECT table, there are $2^L$ {\em levels}.
%% Each level has $2^z$ or $2^{z+1}$ buckets.
%% When the table grows, a single level grows from $2^z$ to $2^{z+1}$ buckets.
%% Once all the levels have $2^{z+1}$ buckets, new growth increases one level from $2^{z+1}$ to $2^{z+2}$ buckets, and so on.




%% Each plastic filter consists of a left and a right {\em side}.
%% Each side has $2^L$ {\em layers}.
%% Each layer is an array of {\em buckets}.
%% Each bucket contains $b$ {\em slots}, each of which holds a {\em fingerprint} of length $F$ or $F-1$.
%% In addition to the fingerprint, each slot contains a {\em tail}, which is a binary string of length less than $T$.

%% Both the fingerprint and the tail are encoded by using a single additional bit each.
%% The number of trailing 0 bits in the encoding indicates the length of the tail.
%% For instance, a tail of length $n$ is stored in the high order bits, then one 1-bit is present, then $T - n$ 0-bits.
%% This encoding uses one additional bit each, so the total size of the slot is $F + T + 2$ bits.

%% Corresponding layers in the two sides of an plastic filter have the same size.
%% Every array of buckets has a size that is a power of two.
%% At all points in time, there is a {\em cursor $c$} in $\mathbb{Z}_{2^L}$ and a value $m$ such that all layers at indices greater than or equal to $c$ have bucket arrays of size $m$, while all layers at indices less than $c$ have bucket arrays of size $2m$.
%% All fingerprints in size-$2m$ layers have length $F-1$, whereas fingerprints in size-$m$ layers can also have size $F$.

%% Each side contains two randomly-chosen operators; each operator is a set of permutations; each permutation operates on $\mathbb{Z}_{2^i}$ for each $i < L + F - 1 \le w$, where $w$ is the word size of the machine.
%% %Each operation below is applied to bit lengths of $L + \lg m$ and $L + \lg m + 1$.
%% To find a key from $\mathbb{Z}_{2^k}$ in an plastic filter, it is first broken up into four pieces, starting from the high-order bits.

%% \begin{enumerate}
%% \item The top $L + \lg m + F - 1$ or $L + \lg m + F$ bits
%% \item The next $T$ bits (the tail)
%% \item The remaining bits, which are discarded
%% \end {enumerate}

%% The top bits are hashed with the permutations, and then the results are broken up into three parts:

%% \begin{enumerate}
%% \item The $L$ most significant bits, indicating the layer
%% \item Since the index of the layer has now been set, the length of its bucket array is now known.
%%   If the bucket array has length $2m$, the next $\lg m + 1$ bits are selected as the bucket index.
%%   Otherwise, the next $\lg m$ bits are.
%% \item $F$ or $F - 1$ bits, representing the fingerprint.
%%   If the bucket array has length $2m$ and the top $L + \lg m + F - 1$ bits were selected and hashed, then only $F-2$ bits are left for the fingerprint.
%%   These are considered {\em invalid}.
%% \end{enumerate}

%% The named parts will be referred to as the {\em layer index}, the {\em bucket index}, the {\em fingerprint}, and the {\em tail}.
%% These four parts together constitute a {\em path}; the sum of the bit lengths of the components is a path's length.
%% By their length constraints (at most $L + \lg m + F$ bits), paths never have a layer index less than $c$ and a fingerprint of length $F$.
%% Because permutations have inverses, the path can be used to reconstruct the top $L + \lg m + F - 1 + T$ or $L + \lg m + F + T$ bits of the key, depending on the length of the bucket index and the fingerprint.

%% \subsection{Operations}

%% To look up a key, two to four paths are first formed, corresponding to the two permutations times the two path lengths.
%% It may be the case that the paths produced by hashing a short key are pointing to locations in a large level.
%% Such paths are ignored.
%% A slot in a bucket matches a path when the keys are identical.\footnote{This was the test in \cite{psw}. In minimal plastic cuckoo filters, the values are also matched - the one in the entry must be a prefix of the one being searched for. This lowers the false positive rate at the cost of extra comparison time.}

%% Insertion follows the usual cuckoo pattern of looking for an empty slot and then kicking out a value if none is found, continuing until all keys have been successfully placed.
%% Minimal plastic cuckoo filters additionally have a temporary stash to handle keys that cannot be placed until a level size increase is done.

%% One difference is the keys, as each side uses a permutation and must reconstruct the top bits of the original key before hashing with the permutations from the opposite side of the table.
%% There are three cases to cover:

%% \begin{itemize}
%% \item Kicking the value in a slot from a layer with index $< c$ to one with an index $\ge c$:
%%   the fingerprints in layers $< c$ have length $F-1$, and the bucket indices have length $1 + \lg m$.
%%   To move an item to a layer $\ge c$, move the low-order bit from the bucket index into a new high-order bit in the fingerprint.
%%   This makes a slot with a fingerprint of length $F$, which is permitted in layers with index $\ge c$.
%% \item Kicking the value with a fingerprint of length $F$ to a layer with index $< c$:
%%   this is simply the reverse of the kick above, so a the high order bit from the fingerprint is moved to be a new low-order bit in the bucket index.
%% \item Kicking the value a fingerprint of length $F-1$ from a layer with index $\ge c$ to a layer with index $< c$:
%%   here, again, we steal a high-order bit from the fingerprint to push to the bucket index as a new low-order bit.
%%   This leaves the fingerprint with length $F-2$, which is invalid.
%%   To fix this, we steal a bit from the tail to be in the fingerprint.

%%   Note that, unlike the cases above, the stolen bit is from the un-permuted domain.
%%   As such, that value needs to be sent through the permutation backwards, have the tail bit appended, then re-hashed, potentially changing the layer index.
%%   No matter what the new layer index is, the concatenated bucket index plus fingerprint has length $\lg m + 1$, which is valid.

%%   If there are no remaining bits in the tail, {\em two} values are inserted; each one constructed by appending a bit to the fingerprint before rehashing.
%%   This essentially turns a single slot into two.
%% \end{itemize}

%% When the hash table is close to full, the cuckoo lookup path will grow.
%% Once the hash table occupancy exceeds some pre-set fill-factor $\alpha$, the two bucket arrays at location $c$ (the cursor) are doubled in size, and their old values are inserted into the table with the newly-doubled arrays.
%% Once $c = 2^L$ and the doubling operation is complete, $c$ is reset to $0$ and the operators are swapped.

TODO: variable-sized stashes

TODO: what is the fpp of the dictionary

TODO: permutation swapping

TODO: combining tails

TODO: hashing entropy enough when tail is long and head is short, or do all items in bucket b necessarily map to the same bucket c?

TODO: longer fingerprints lead to higher fill factors

TODO: show phase change of when a filter can be filled with a given size

TODO: Show how much time is spent in upsize



\bibliographystyle{alpha}
\bibliography{plastic}

\appendix
\section{MPCF pseudocode}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
LookupSide(hashed: `$\ints_2^{64}$`, side: `$\ints_2$`, mpcf: MPCF(U, k)) {
  permuted := mpcf.Permutation[side](hashed[0, k+12))
  level_number := permuted[0, 5)
  if (level_number `$\ge$` mpcf.cursor) {
    bucket := mpcf.Level[level_number][permuted[5, k + 5)]
    if (LookupBucket(permuted[k+5, k+12),
                     hashed[k+12, k+18), bucket)) {
      return True
    }
  }
  permuted = mpcf.Permutation[side](hashed[0, k+13))
  level_number = permuted[0, 5)
  level := mpcf.Level[level_number]
  middle := (level_number `$\ge$` mpcf.cursor) then k + 5 else k + 6
  bucket := level[permuted[5, middle)]
  return LookupBucket(permuted[middle, k+13),
                      hashed[k+13, k+19), bucket)
}

MLookup(input: U, mpcf: PCF(U, k)) {
  hashed := mpcf.HashFunction(input)
  for (side : {0, 1}) {
    if (LookupSide(hashed, mpcf.Side[side], mpcf)) return True
  }
  return False
}
\end{lstlisting}
\caption{The lookup operation in an MPCF.}
\end{figure}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
MInsertSide(level_number: `$\ints_{32}$`, bucket_number: `$\ints_2^k \cup \ints_2^{k+1}$`,
            fingerprint `$\ints_2^7 \cup \ints_2^8$`, tail: `$\sum_{i \le 6}\ints_2^i$`, side: `$\ints_2$`,
            mpcf: MPCF(U, k)) {
  bucket := mpcf.Level[level_number][bucket_number]
  new_slot := InsertBucket(fingerprint, tail, bucket)
  if (new_slot == `$\bot$`) return
  fingerprint = new_slot.fingerprint
  tail = new_slot.tail
  permuted := Concat(level_number, bucket_number, fingerprint)
  hashed := mpcf.Permutation[side]`$^{-1}$`(permuted)
  permuted = mpcf.Permutation[1 - side](hashed)
  MInsertPermuted(permuted, tail, side, mpcf)
}

MInsertPermuted(permuted: `$\ints_2^{k+12} \cup \ints_2^{k+13}$`, tail: `$\sum_{i \le 6}\ints_2^i$`, side: `$\ints_2$`,
                mpcf: MPCF(U, k)) {
  level_number := permuted[0, 5)
  if (|permuted| == k + 13) {
    middle := if (level_number `$\ge$` mpcf.cursor) then k+5 else k+6
    MInsertSide(level_number, permuted[5, middle),
                permuted[middle, k+13), tail, 1 - side)
    return
  }
  if (level_number `$\ge$` mpcf.cursor) {
    permuteds := {permuted}
  }
  if (permuted, tail) := steal(permuted, tail) {
    permuteds := {permuted}
  } else {
    (permuted0, permuted1, tail) := steal(permuted, tail)
    permuteds := {permuted0, permuted1})
  }
  for (p : permuteds) {
    MInsertSide(level_number, p[5, k+5), p[k+5, k+12), tail, 1 - side)
  }
}


\end{lstlisting}
\caption{Pseudocode for the insert operation on MPCFs}
\end{figure}


\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
InsertMPCF(key: U, mpcf: MPCF(U, k)) {
  hashed := mpcf.HashFunction(key)
  permuted := mpcf.Permutation[0](hashed[0, k+13))
  level_number := permuted[0, 5)
  middle := if (level_number `$\ge$` mpcf.cursor) then k+5 else k+6
  bucket_number := permuted[5, middle)
  fingerprint := permuted[middle, k+13)
  tail := hashed[k+13, k+19)
  MInsertSide(level_number,  bucket_number, fingerprint, tail, 0)
}
\end{lstlisting}
\caption{Pseudocode for the insert operation on MPCFs}
\end{figure}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
UpsizeMPCF(key: U, mpcf: MPCF(U, k)) {
  old := mpcf.Level[cursor]
  mpcf.Level[cursor] = new Level(2^{k+1})
  mpcf.cursor = mpcf.cursor + 1
  for (side : {0, 1}) {
    for (bucket_index : `$\ints_2^k$`) {
      for (slot : old.MBucket[side][bucket_index]) {
        if (slot `$\neq \bot$`) {
          permuted := Concat(cursor - 1, bucket_index,
                             slot.fingerprint)
          cursor = cursor - 1
          hashed := mpcf.Permutation[side]`$^{-1}$`(permuted)
          cursor = cursor + 1
          permuted = mpcf.Permutation[side](hashed)
          MInsertPermuted(permuted, slot.tail, side, mpcf)
        }
      }
    }
  }
}
\end{lstlisting}
\caption{Pseudocode for the upsize operation on MPCFs}
\end{figure}


\end{document}

%%  LocalWords:  growable lookups quotienting AMQ Upsize PCF PCF's
%%  LocalWords:  HashFunction LookupBucket IsPrefixOf pcf InsertPCF
%%  LocalWords:  InsertSide InsertBucket RandomSlotIn otherSide PCFs
%%  LocalWords:  Concat upsize doublings DySECT MPCF MSlot MBucket
%%  LocalWords:  upsizes TODO fpp LookupSide mpcf MLookup MInsertSide
%%  LocalWords:  MInsertPermuted permuteds MPCFs InsertMPCF
%%  LocalWords:  UpsizeMPCF
