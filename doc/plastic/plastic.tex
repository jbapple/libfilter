\documentclass[letterpaper, 11pt]{article}

\pdfoutput=1

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{color}
\usepackage{graphicx}
\PassOptionsToPackage{hyphens}{url}\usepackage[pdftitle={Stretching your data with plastic filters}]{hyperref}
\usepackage{microtype}
\usepackage[strings]{underscore}
\usepackage{doi}
\usepackage{nicefrac}
\usepackage{listings}
%\usepackage{todonotes}
%\usepackage{epigraph}
\usepackage{tikz}


\newtheorem{theorem}{Theorem}

\lstset{
%    frame=tb, % draw a frame at the top and bottom of the code block
%    tabsize=2, % tab space width
%    showstringspaces=false, % don't mark spaces in strings
%    numbers=left, % display line numbers on the left
%    commentstyle=\color{green}, % comment color
%    keywordstyle=\color{blue}, % keyword color
%    stringstyle=\color{red}, % string color
    basicstyle=\small\ttfamily,
    basewidth = {.48em}
}

\DeclareMathOperator{\adj}{adj}

%\renewcommand\UrlFont{\color{blue}\rmfamily}

%% \newcommand{\reals}{\mathbb{R}}
%% \newcommand{\rats}{\mathbb{Q}}
%% \newcommand{\nats}{\mathbb{N}}
\newcommand{\ints}{\mathbb{Z}}
%% \newcommand{\cplx}{\mathbb{C}}
\newcommand{\defeq}{\;\genfrac{}{}{0pt}{2}{\text{def}}{=}\;}

%\pagestyle{empty}

% https://tex.stackexchange.com/questions/171803/change-font-size-of-the-verbatim-environment
% \newcommand{\verbatimfont}[1]{\renewcommand{\verbatim@font}{\ttfamily#1}}

%% \usepackage{etoolbox}
%% \makeatletter
%% \patchcmd{\@verbatim}
%%   {\verbatim@font}
%%   {\verbatim@font\small}
%%   {}{}
%% \makeatother


\begin{document}

\title{Stretching your data with plastic filters}
\author{Jim Apple \\
  jbapple@apache.org}

\maketitle
%\thispagestyle{empty}

%\epigraph{If you can look into the seeds of time, and say which grain will grow and which will not, speak then unto me.}{Macbeth}{Shakespeare}

\section{Introduction}

While there are many filter structures that support approximate membership queries on sets with a given maximum size, the question of extensible (or {\em incremental} or {\em growable}) filters is little studied.
The classic answer is to create a sequence of Bloom filters, possibly of increasing sizes and/or lower target false positive probability.
Inserts occur on the last filter to be created and lookups must search each filter.

Even when this keeps the false positive rate low, lookup times balloon from constant to logarithmic or even linear.~\cite{psw,logarithm,consistent-cuckoo} %The Dynamic Cuckoo Filter
Additionally, the space usage can grow up to $\Omega(n \lg n)$, at which point a traditional hash table would do the same work in the same space.
Later authors consider cuckoo filters in which, when the filter grows, the size of the fingerprint shrinks, thereby increasing the false positive probability.~\cite{logarithm,morton-journal,vacuum,rsqf}

In \cite{psw}, the authors introduce a structure that performs lookups in $O(1)$ time while still allowing the structure to grow and keep a low false positive rate (not exceeding a threshold specified when the structure was created) all while using no more than $O(\lg \lg n + \lg (1/\varepsilon))$ words of space per element.
Section~\ref{pcf} presents {\em plastic cuckoo filters} (``PCFs''), a practical instantiation of this model, an outstanding challenge from \cite{psw}.

The structure in~\cite{psw} depends on \cite{succinct}.
As noted in \cite{dysect}, dictionaries like \cite{succinct} do not directly address the problem of using low space when the dictionary is not near the maximum space it will need.
For example, as a set grows from size $n$ to $2n$ in increments of one, the dictionary in \cite{succinct} will reconstruct the entire dictionary at least once.
Furthermore, if each reconstruction increases the capacity from $m$ to $(1 + \delta)m$, $1/\lg(1+\delta)$ rebuilds will occur.
Finally, non-power-of-two sizes pose challenges for quotienting, a technique needed to reduce the space usage by up to one bit per element.~\cite{change-your-base, cleary-quotient}

Section~\ref{mpcf} presents {\em minimal plastic cuckoo filters} (``MPCFs'') based on~\cite{dysect}.
MPCFs re-allocate and refills the table only once for each time the table doubles in size, but do so without increasing the capacity and space usage of the table beyond a small percentage over the size of the data contained within.

Section~\ref{eval} presents {\em plastic block filters}, a variation of the ``warm-up'' structure from \cite{psw}.
That section also describes experimental performance results on all plastic filters.

\section{Plastic cuckoo filters}
\label{pcf}
Plastic cuckoo filters (``PCFs'') are approximate membership query structures that offer the following operations:

\begin{itemize}
\item {\bf Create} initializes an empty filter with the given size
  %and false positive probability, and expected {\em growth factor}.
  %A growth factor is the maximum number of doublings the structure must be able to undergo while maintaining the given false positive probability.
\item {\bf Insert} adds a key to the filter.
  This takes $O(1)$ expected time.
  It can fail when the filter is nearly full.
\item {\bf Lookup} takes a key and returns \verb|True| if the key is in the structure and \verb|False| with probability $1-\varepsilon$ if the key is not in the structure.
  It takes $O(1)$ worst-case time
\item {\bf Upsize} doubles the capacity of the filter in $\Theta(n)$ time.
\end{itemize}

We use quotienting cuckoo tables (as in backyard cuckoo hashing~\cite{backyard}) to store the data in a plastic cuckoo filter.
The quotienting table uses permutation hash functions to transform the input key into two different hash values such that either can be used to reconstruct a portion of the original key.

The top $\lg n - O(1)$ bits are omitted from the stored hash values, since these are implicitly stored in the location of the key within the table.
In this way, data can be moved from one sub-table to the other via key reconstruction, even without storing the key explicitly.

An element consists of two groups of bits: one of size 10, and the other of size up to 5.
The former is called the fingerprint and the latter is called the tail.
A bucket consists of four (possibly empty) slots, each of which can hold one element.
A side consists of $2^k$ buckets for some $k$ as well as a permutation on $\ints_2^{k+10}$.\footnote{We do not distinguish between $\ints_2^z$ and $\ints_{2^z}$.}
A PCF consists of two sides and one hash function that produces a 64-bit key.
The two sides have the same number of buckets but different permutations.

A lookup begins by hashing a key with the PCF's hash function.
Then the lookup operation does the following:

\begin{enumerate}
\item Applies a permutation to the most-significant $k+10$ bits in the key.
\item Reserves the next 5 bits of the key; this will be the key's tail.
\item Using the most-significant $k$ bits in the result, selects a bucket.
(The remaining 10 bits in the permuted value are the fingerprint.)
\item Checks to see if any slot contains an element with an identical fingerprint.
If so, checks if the element's tail is a prefix of the key's tail.
If yes, returns \verb|True|.
Otherwise, returns \verb|False|.
\end{enumerate}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
Element := {fingerprint: `$\ints_2^{10}$`, tail: `$\cup_{i \le 5} \ints_2^i$`}
Slot := Element`$_\bot$`
Bucket := Slot[4]
Side(k) := {Bucket[2^k], Permutation: `$S_{2^{k+10}}$`}
PCF(U, k) := {Side(k)[2], HashFunction: `$U \to \ints_2^{64}$`}
\end{lstlisting}
\caption{\protect
The types of a PCF.
  $S_i$ is the symmetric group on $\ints_i$.
  \texttt{T}$_\bot$ means the type \texttt{T} extended with the element $\bot$, indicating ``null'' or ``empty''.
  As above, pseudocode will not make a distinction between $\ints_2^i$ and $\ints_{2^i}$.
  \texttt{T[n]} denotes an array of $n$ values of type $T$.
  Structs are denoted by curly brackets \{\}, and members of structs can be referenced by their name or by their type.
  For instance, if \texttt{s} is a \texttt{Side(k)}, then \texttt{s.Bucket} and \texttt{s.Permutation} are both meaningful expressions.
}
\end{figure}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
LookupBucket(fingerprint, tail, bucket) {
  for (element : bucket) {
    if (element.fingerprint == fingerprint
        && element.tail IsPrefixOf tail) {
      return True
    }
  }
  return False
}

Lookup(input: U, pcf: PCF(U, k)) {
  hashed := pcf.HashFunction(input)
  for (side : pcf.Side[0], pcf.Side[1]) {
    permuted := side.Permutation(hashed[0, k+10))
    tail := hashed[k+10, k+15)
    bucket := side.Bucket[permuted[0, k)]
    if LookupBucket(permuted[k, k+10), tail, bucket) return True
  }
  return False
}
\end{lstlisting}
\caption{The lookup operation on PCFs.
}
\end{figure}

The insert operation first searches for the key, and, if found, returns.
Otherwise, insert places the key's fingerprint and tail in an empty slot, if one is found.
If none is found, insert selects an occupied slot from the bucket to {\em kick}: the element in this slot will be moved to the other side.

The kick operation first reconstructs the high order $k + 10$ bits of the key by concatenating the $k$ bits of the bucket index and the $10$ bits of the fingerprint, then applying that side's permutation in reverse to the value.
Using the same tail (this does not get permuted), the kick operation then recursively inserts the data into the opposite side using the insert algorithm described above.

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
InsertBucket(fingerprint, tail, bucket) {
  new_element := {fingerprint := fingerprint, tail: tail}
  for(slot : bucket) {
    if (slot == `$\bot$`) {
      slot := new_element
      return `$\bot$`
    }
  }
  swap(new_element, RandomSlotIn(bucket))
  return new_element
}

InsertSide(hashed: `$\ints_2^{k+10}$`, tail: `$\cup_{i \le 5} \ints_2^i$`,
           side: Side(k), otherSide: Side(k)) {
  permuted := side.Permutation(hashed)
  bucket := side.Bucket[permuted[0, k)]
  new_element = InsertBucket(permuted[k, k+10), tail, bucket)
  if (new_element == `$\bot$`) return
  Kick(side, otherSide, permuted[0, k), new_element)
}

Kick(side: Side(k), otherSide: Side(k),
     bucket_index: `$\ints_{2^k}$`, element) {
  permuted := Concat(bucket_index, element.fingerprint)
  hashed := side.Permutation`$^{-1}$`(permuted)
  InsertSide(hashed, element.tail, otherSide, side)
}

InsertPCF(input: U, pcf: PCF(U, k)) {
  if (Lookup(input, pcf)) return
  hashed := pcf.HashFunction(input)
  InsertSide(hashed[0, k+10), hashed[k+10, k+15),
             pcf.Side[0], pcf.Side[1])
}
\end{lstlisting}
\caption{Pseudocode for the insert operation on PCFs}
\end{figure}

The upsize operation begins by creating a new PCF.
To transfer the data, it uses the kick algorithm, but needs an alteration, since the number of buckets is now $2^{k+1}$.
To produce a key with that many bits, upsize first reconstructs the $k+10$ bits of the key that were used to construct the bucket index and fingerprint.
Then a bit is ``stolen'' from the tail and appended onto the end of the key.
Since the tail was taken unaltered from the key, this gives $k+11$ bits of the original key.
The new tail is now decreased in size by one.
The key and the new tail of it can now be inserted into one of the sides of the new PCF as described above.

This works as long as the tail has positive length.
If the tail has length zero, there is nothing to steal from.
Instead, two candidate keys are created from the reverse-permuted $k+10$ bits by appending a zero and a one.
It's indeterminate which one of these was in the original key, so both are inserted.
\cite{psw} show that the fpp is less than $2^{-8}$, although in PCF filters the actual value will be smaller, since the tail is checked as well.

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
Steal(head, tail) {
  if (|tail| == 0) {
    return Concat(head, 0), Concat(head, 1), tail
  }
  return Concat(head, tail[0]), tail[1, |tail|)
}

Upsize(pcf: PCF(U, k)) {
  result := PCF(U, k + 1)
  for (side : pcf) {
    for (bucket_index : `$\ints_{2^k}$`) {
      for (element : side.Bucket[bucket_index]) {
        permuted := Concat(bucket_index, element.fingerprint)
        hashed := side.Permutation`$^{-1}$`(permuted)
        stolen := Steal(hashed, element.tail)
        if (head, tail) := stolen {
          InsertSide(head, tail, result.Side[0],
                                 result.Side[1])
        } else {
          (head0, head1, tail) := stolen
          InsertSide(head0, tail, result.Side[0],
                                  result.Side[1])
          InsertSide(head1, tail, result.Side[0],
                                  result.Side[1])
        }
      }
    }
  }
  pcf = result
}
\end{lstlisting}
\caption{Pseudocode for the upsize operation on PCFs}
\end{figure}

%% \subsection{Space and false positive analysis}

%% In \cite{psw}, the dictionary is broken up into subsequences of size $2^i$.
%% Each subsequence $S_i$ contains the inserted keys with insertion order number in $[2^i, 2^{i+1})$.
%% Only when transitioning subsequences is the steal operation performed.
%% However, in PCFs, transitions happen when the dictionary is near full.
%% This does not necessarily correspond to the sequences.
%% Firstly, the $i$th dictionary cannot hold $2^i$ keys, just $\alpha 2^i$, where $\alpha$ si the ``fill factor''.
%% Second, the dictionary is sized according to the number of entries, while the structure in \cite{psw} is sized according to the number of insertions.
%% These differ, as the number of entries for a sequence grows as the sequence lengthens as a result of the steals against an empty tail.

%% The false positive probability depends on the number of elements with different tail lengths.
%% Specifically, in a dictionary with $n$ elements where $p(i)$ is the number of elements with tail of length $i$, the false positive probability is less than

%% \[
%% 8 n^{-1} \sum_{i \le 7} 2^{-i-8}p(i)
%% \]

%% \[
%% 2^{-5} n^{-1} \sum_{i \le 7} 2^{-i}p(i)
%% \]

%% In any insertion sequence $I$, let $\alpha_I$ be the smallest number such that a dictionary with $\alpha_I x$ entries and capacity for $x$ entries is upsized.



%% \begin{theorem}
%%   $p(i)$
%% \end{theorem}~\begin{proof}
%% Assuming the dictionary starts with both sides having Bucket arrays of size 1, and thus having an element capacity of 8, the first $8 \alpha$ elements are inserted before any upsizing and therefore have tails of the full length, 7.
%% In this first phase, a candidate gets compared to at most $8 \alpha$ elements and has a $2^{-15}$ chance of collision with each, for a false positive probability (``fpp'') of less than $2^{-12}$.
%% Once the table has resized to having capacity 16, at most 8 of the slots are filles with tails of length 6.
%% The addition of at most 8 more items of length 7 makes

%% %% \[
%% %% p(i) =
%% %% \begin{cases}
%% %% 8 & i = 6\\
%% %% 8 & i = 7\\
%% %% 0 & \text{otherwise}
%% %% \end{cases}
%% %% \]

%% %% and thus the fpp is less than $8 \cdot 16^{-1} (2^{-14}\cdot 8 + 2^{-15}\cdot 8) = 2^{-12} + 2^{-13}$.
%% %% Repeating, we get

%% %% \[
%% %% p(i) =
%% %% \begin{cases}
%% %% 8 & i = 5\\
%% %% 8 & i = 6\\
%% %% 16 & i = 7\\
%% %% 0 & \text{otherwise}
%% %% \end{cases}
%% %% \]

%% %% and thus the fpp is less than $8 \cdot 32^{-1} (2^{-13}\cdot 8 + 2^{-14}\cdot 8 + 2^{-15}\cdot 16) = 2^{-12} + 2^{-13} + 2^{-13}$.

%% %% \[
%% %% p(i) =
%% %% \begin{cases}
%% %% 8 & i = 4\\
%% %% 8 & i = 5\\
%% %% 16 & i = 6\\
%% %% 32 & i = 7\\
%% %% 0 & \text{otherwise}
%% %% \end{cases}
%% %% \]

%% %% and thus the fpp is $8 \cdot 64^{-1} (2^{-12}\cdot 8 + 2^{-13}\cdot 8 + 2^{-14}\cdot 16 + 2^{-15}\cdot 32) = 2^{-12} + 2^{-13} + 2^{-13} + 2^{-13}$.

%% %% This pattern repeats until and including

%% %% \[
%% %% p(i) =
%% %% \begin{cases}
%% %% 8 & i = 0\\
%% %% 2^{2+i} & \text{otherwise}
%% %% \end{cases}
%% %% \]

%% %% when $n = 2^{10}$ after inserting $2^10$.

%% %% so the fpp is less than $2^{-12} + 6 \cdot 2^{-13}$

%% %% After that, the next $p(i)$ is

%% %% \[
%% %% p(i) =
%% %% \begin{cases}
%% %% 3 \cdot 2^3 & i = 0\\
%% %% 2^{10} - 8 & i = 7 \\
%% %% 2^{3+i} & \text{otherwise}
%% %% \end{cases}
%% %% \]

%% %% \[
%% %% p(i) =
%% %% \begin{cases}
%% %% 4 \cdot 2^4 & i = 0\\
%% %% 2^{10} - 2\cdot2^2 & i = 6 \\
%% %% 2^{11} - 3\cdot 2^3 & i = 7 \\
%% %% 2^{4+i} & \text{otherwise}
%% %% \end{cases}
%% %% \]

%% %% \[
%% %% p(i) =
%% %% \begin{cases}
%% %% 9 \cdot 2^9 & i = 0\\
%% %% 2^{10} - 2 \cdot 2^2 & i = 1 \\
%% %% 2^{11} - 3 \cdot 2^3 & i = 2 \\
%% %% 2^{12} - 4 \cdot 2^4 & i = 3 \\
%% %% 2^{13} - 5 \cdot 2^5 & i = 4 \\
%% %% 2^{14} - 6 \cdot 2^6 & i = 5 \\
%% %% 2^{15} - 7 \cdot 2^7 & i = 6 \\
%% %% 2^{16} - 8 \cdot 2^8 & i = 7 \\
%% %% \end{cases}
%% %% \]

%% %% \[
%% %% p(i) =
%% %% \begin{cases}
%% %% a  & i = 0\\
%% %% b & i = 1 \\
%% %% c & i = 2 \\
%% %% d & i = 3 \\
%% %% e & i = 4 \\
%% %% f & i = 5 \\
%% %% g & i = 6 \\
%% %% h & i = 7
%% %% \end{cases}
%% %% \]

%% $p$ with total size $m = 2^j$

%% changes to

%% \[
%% p(i) =
%% \begin{cases}
%% p(1) + 2p(0) & i = 0\\
%% p(2) & i = 1 \\
%% p(3) & i = 2 \\
%% p(4) & i = 3 \\
%% p(5) & i = 4 \\
%% p(6) & i = 5 \\
%% p(7) & i = 6 \\
%% 2^j - p(0) & i = 7 \\
%% \end{cases}
%% \]

%% with total size $2^{j+1}$.

%% The fpp changes from

%% \[
%% \varepsilon 8 \cdot 2^{-j} \left(\sum p(i) 2^{-i}\right)
%% \]

%% to

%% \[
%% 2^{-j + 2} \left(p(1) + 2p(0) + (2^j - p(0))2^{-7} + \sum_{i = 1}^{i < 7} p(i) 2^{-i+1}\right)
%% \]

%% if $p(0) < 3 \cdot 2^{j-2}$, then this is at most

%% \[
%% 2^{-j + 2} \left(p(1) + 2 \cdot  3 \cdot 2^{j-2} + (2^j -  3 \cdot 2^{j-2})2^{-7} + \sum_{i = 1}^{i < 7} p(i) 2^{-i+1}\right)
%% \]

%% \[
%% 2^{-j + 2} \left(p(1) + 3 \cdot 2^{j-1} + (2^{j-2})2^{-7} + \sum_{i = 1}^{i < 7} p(i) 2^{-i+1}\right)
%% \]

%% \[
%% 2^{-j+2} \left(p(1) + 3 \cdot 2^{j-1} + (2^{j-2})2^{-7} + \sum_{i = 1}^{i < 7} p(i) 2^{-i+1}\right)
%% \]

%% \[
%% \varepsilon (2^{-j+2}p(1) + 3 \cdot 2^{1} + 2^{-7} + \sum_{i = 1}^{i < 7} p(i) 2^{-i-j+3}
%% \]

%% \[
%% \varepsilon (2^{-j+2}p(1) + 12 + 2^{-7} + \sum_{i = 1}^{i < 7} p(i) 2^{-i-j+3}
%% \]

%% Everything except 12 is vanishing, so 

%% \[
%% \begin{cases}
%% 2^{10} - 2 \cdot 2^2 & i = 1 \\
%% 2^{11} - 3 \cdot 2^3 & i = 2 \\
%% 2^{12} - 4 \cdot 2^4 & i = 3 \\
%% 2^{13} - 5 \cdot 2^5 & i = 4 \\
%% 2^{14} - 6 \cdot 2^6 & i = 5 \\
%% 2^{15} - 7 \cdot 2^7 & i = 6 \\
%% 2^{16} - 8 \cdot 2^8 & i = 7 \\
%% \end{cases}
%% \]


%% \[
%% p(i) =
%% \begin{cases}
%%  -2 \cdot 2^2 + 10 \cdot 2^{10} & i = 0\\
%% 2^{11} - 3 \cdot 2^3 & i = 1 \\
%% 2^{12} - 4 \cdot 2^4 & i = 2 \\
%% 2^{13} - 5 \cdot 2^5 & i = 3 \\
%% 2^{14} - 6 \cdot 2^6 & i = 4 \\
%% 2^{15} - 7 \cdot 2^7 & i = 5 \\
%% 2^{16} - 8 \cdot 2^8 & i = 6 \\
%% 2^{17} - 9 \cdot 2^9 & i = 7 \\
%% \end{cases}
%% \]

%% \[
%% p(i) =
%% \begin{cases}
%% - 5 \cdot 2^3 + 11 \cdot 2^{11} & i = 0\\
%% 2^{12} - 4 \cdot 2^4 & i = 1 \\
%% 2^{13} - 5 \cdot 2^5 & i = 2 \\
%% 2^{14} - 6 \cdot 2^6 & i = 3 \\
%% 2^{15} - 7 \cdot 2^7 & i = 4 \\
%% 2^{16} - 8 \cdot 2^8 & i = 5 \\
%% 2^{17} - 9 \cdot 2^9 & i = 6 \\
%% 2^{17} - 9 \cdot 2^9 & i = 6 \\
%% \end{cases}
%% \]

%% with $n = 2^{11} - 2^4 + 3 \cdot ^3$ after inserting $2^11$

%% and then

%% \[
%% p(i) =
%% \begin{cases}
%% 4 \cdot 2^4 & i = 0\\
%% 2^{4+i} & \text{otherwise}
%% \end{cases}
%% \]

%% with $n = 2^{12} - 2^5 + 4 \cdot 2^4$


%% following the pattern

%% \[
%% p(i) =
%% \begin{cases}
%% j \cdot 2^j & i = 0\\
%% 2^{j+i} & \text{otherwise}
%% \end{cases}
%% \]

%% when $n = j \cdot 2^j - 2^{j+1} + 2^{8+j}$ after inserting

%% In this case, the false positive probability is 

%% \[
%% 2^{-5} \cdot (j \cdot 2^j - 2^{j+1} + 2^{8+j})^{-1}(j \cdot 2^j + 2^{-1}2^{j+1} + 2^{-2}2^{j+2} \dots)
%% \]

%% \[
%% 2^{-5} \cdot (j \cdot 2^j - 2^{j+1} + 2^{8+j})^{-1}(j \cdot 2^j + 7\cdot2^j)
%% \]

%% \[
%% 2^{-5} \cdot (2^j(j - 2 + 2^8))^{-1}2^j(j + 7)
%% \]

%% \[
%% 2^{-5} (j - 2 + 2^8)^{-1}(j + 7)
%% \]

%% \[
%% \frac{j+7}{2^5 (j - 2 + 2^8)}
%% \]

%% \end{proof}

%% That is only approximated in PCFs, as the 

%% The calculations of how many slots the accumulation of these doublings produces is the key calculation in the space consumption analysis in~\cite{psw}.
%% That is crucial as well for the false positive rate
%% For the concrete setting here, if the dictionary starts with $k = 0$ (each side having size 1 bucket), then after $m$ upsizes, if $m < 7$, $2^{m+2}(1 - \delta)$ keys have been inserted and the same number are in the dictionary.
%% Half of the tails have length seven, a quarter have length six, and so on.
%% The false positive probability is $2^{m+2}(1 - \delta) \cdot 2^{-m-8}(m \cdot 2^{-8}) = m(1-\delta)2^{-14}$, which is between $6.1E-5$ and $4.2E-4$.
%% TODO: experimentally different. Make graph.
%% %% check to see if the tail in that slot is a prefix of the 

%% %% To look up a key

%% %% Plastic cuckoo filters are based on this filter, but additionally add a value to each key.
%% %% The value is the next $\lg d$ bits of the key, where $d$ is the growth factor.



%% %% Plastic cuckoo filters are based on a type of bloomier filter.
%% %% A bloomier filter is an AMQ supporting lookups, not just membership queries.
%% %% Given a domain and range $D$ and $R$ where $D \subset U$ and $M$ is a map from $D$ to $R$, a query for $x$ in a bloomier filter for $M$ returns $M(x)$ if $x \in D$ and $\bot$ with probability $1-\varepsilon$ when $x \in U \backslash D$, and otherwise returns an arbitrary value in $R$.

%% %% Next we will form a quotienting cuckoo map.
%% %% A quotienting cuckoo map has a domain of $\ints_d$ and a range of $\ints_r$.
%% %% A standard cuckoo map would use $d + r$ bits per unit of capacity.
%% %% A quotienting cuckoo table uses $d + r + \lg b -  \lg m $ where $m$ is the capacity of the table and $b$ is the size of the bucket.


%% %% In an elastic filter, the permuted key has length $\lg \nicefrac{1}{\varepsilon} + \lg m - \lg b$ while the range consists of all sequences of bits of length less than $\lg\lg \nicefrac{U}{n} + O(1)$.
%% %% When the table is nearly full, meaning that further additions would likely fail, the size is doubled.
%% %% This increases the size of the unstored bits by 1, so the number of stored bits would be smaller, as well.
%% %% Instead of letting that happen, a bit is ``stolen'' from the range of sequences of bits.

%% %% This shortens the value in the range, but the range stays the same.
%% %% If there are no bits to steal becuase the value is the empty string, {\em two} new values are generated to insert into the new, larger table: one with a one appended to the stored bits, one with a zero.
%% %% This follows directly from \cite{psw}.

\section{Minimal plastic cuckoo filter}
\label{mpcf}

The previous structure suffers from a step-function space usage:
at each point, the structure has a size which is a power of two, sometimes allocating much more space than will be needed.
To address this, this section describes a similar structure using DySECT to reduce the space usage to only what is needed.~\cite{dysect}

A DySECT table consists of some number of {\em levels} (256 in the original work).
As the table gets more and more full, the table grows by doubling the size of one of its levels..

In a minimal plastic cuckoo filter (``MPCF''), each element has a fingerprint of size 8 or 9 and a tail of size up to 5.
A bucket consists of four (possibly empty) slots, each of which can hold one element.
A level consists of two tables of the same size, each with $2^k$ buckets for some $k$.
The table consists of four permutations, one hash function, $32$ levels, and one cursor pointing to some index in the set of levels.
The maximum and minimum $k$ across all levels differ by at most 1.
Levels at location less than the cursor have the larger size.
If all levels have the same size, the cursor must be 0.

The permutations are grouped by side, two for each.
The permutations are on values with length $k + 13$ and $k + 14$, where $2^k$ is the size of the smallest table, measured in buckets.

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
MElement := {fingerprint: `$\ints_2^8 \cup \ints_2^9$`, tail: `$\cup_{i \le 5} \ints_2^i$`}
MSlot := MElement`$_\bot$`
MBucket := MSlot[4]
Level(k) := MBucket[2][2^k] `$\cup$` MBucket[2][2^(k+1)]
Permutation(k) := `$S_{2^{k+12}} \times S_{2^{k+13}}$`
MPCF(U, k) := {cursor: `$\ints_{32}$`,
               Level(k)[32],
               Permutation(k)[2],
               HashFunction: `$U \to \ints_2^{64}$`}

\end{lstlisting}
\caption{The types of an MPCF.
``$\times$'' means Cartesian product.
}
\end{figure}

If there are larger and smaller levels, then every element in the larger levels has a fingerprint of size 8, not 9.
This is because the implicitly-stored part of the key is one-bit longer in the larger levels.

In an MPCF, upsize only increases the size of one of the levels, not the whole structure.
As a result, the capacity of the filter tracks more closely the number of entries in the table.

A lookup operation in an MPCF first applies each of the four permutations to the hashed key.
For the permutations on $k + 14$ bits, the first five bits indicate the level, the next $k$ or $k+1$ indicate the bucket, and the remaining 8 or 9 bits are the fingerprint.
Lookup proceeds as it does in the PCF case, by checking if fingerprints match and if the stored tail is a prefix of the tail of the key being looked up.
For the permutations on $k + 13$ bits, the first five bits again indicate the level.
If the level has tables with $2^{k+1}$ buckets, the permuted key is not used for lookup; to do otherwise would leave only $k+13 - 5 - (k+1) = 7$ bits for the fingerprint, which is not possible.
That key is simply skipped and the lookup continues with the next key. %See Figure \ref{mpcf-insert}.
Otherwise, the level has tables with $2^k$ buckets, and we can proceed as in the $k+14$ case.

%% Upsize only increases the size of one level.
%% After 31 upsizes, the next one makes all of the levels the same size.
%% At that point, two new permutations must be initialized to handle new longer key prefixes.

During a kick operation, an element may move between levels with differently-sized arrays of buckets.
This poses no problem when the fingerprint has size 9, but when the fingerprint has size 8 and the level moved from has a bucket array of size $2^k$ and the level moved to has a bucket array of size $2^{k+1}$,  there are not enough bits in the fingerprint.
As above, we steal bits from the tail, and, as above, if there are no bits to steal, two new key prefixes are created and inserted, as one of them must be the prefix of the original key.

Pseudo code for lookup, insert, and upsize are available in Appendix \ref{mpcf-appendix}.

\section{Evaluation}
\label{eval}

TODO: graph different MPCF variants based on level size, fingerprint size

TODO: graph raw fpp?

TODO: graph fill factor

TODO: mergeability

TODO: freeze/thaw operations with ribbon filters

TODO: reference github libfilter

TODO: compare standard bloom filters, block bloom filters, filters with exponentially decreasing fpp, and cuckoo filters

For performance testing, we compare with the ``warm-up'' filter from \cite{psw}, using block Bloom filters, which we call Plastic block filters (``PBFs''). \cite{block-bloom}
We also equip both PCFs and MPCFs with variable sized stashes. \cite{stash}
Finally, we set both filters to upsize when they are 90\% full or their stashes have size greater than 4.

\begin{figure}
  \includegraphics[width=\textwidth]{deficiency}
  \caption{
    There is a lower bound on the amount of space that must be used to form an approximate membership query structure with a given false positive rate: $\lg \nicefrac{1}{\varepsilon}$ bits per element.
    Any additional space is, in a sense, ``wasted''.
    In another sense, this overstates the waste, as the best dynamic structures, like Bloom filters and semi-sorted cuckoo filters, do not achieve the lower bound.
    Lower is better.
  }
\end{figure}

%% \begin{figure}
%%   \includegraphics[width=\textwidth]{insert-deficiency}
%%   \caption{
%%     Comparing both the wasted space of each filter type with the absent lookup performance.
%%     Lower left is better.
%%   }
%% \end{figure}

\begin{figure}
  \includegraphics[width=\textwidth]{space}
  \caption{
    The amount of space used by each filter at the given number of keys inserted.
  }
\end{figure}


\begin{figure}
  \includegraphics[width=\textwidth]{insert}
  \caption{
    Insert times for filters.
TODO: the dip is an artifact; redo with more samples and longer time between timer start \& stop.
  }
\end{figure}

\begin{figure}
  \includegraphics[width=\textwidth]{lookup-present}
  \caption{
    Lookup times for filters when the key is present.
  }
\end{figure}

\begin{figure}
  \includegraphics[width=\textwidth]{lookup-absent}
  \caption{
    Lookup times for filters when the key is absent.
  }
\end{figure}

\subsection{Discussion}

The MPCF offers lower space than the other two filters, but its performance is substantially worse.
It has significant insertion time increases when it is hard to find a kick sequence; in this case the insert operation repeatedly calls upsize until a place can be found for the element.
This behavior is also seen in the PCF, though it is easier to understand there, as the filters start out after each upsize as at least half empty, which is not true for MPCFs.
This cyclic behavior was noted in the original DySECT paper. \cite{dysect}
Performance for lookup is also cyclic as the size of the stashes grow and shrink, which corresponds to the fullness of the filter.

PBFs, which have an $\Omega(\lg n)$ lookup cost, come out ahead of both plastic filters in both insert and lookup costs except when over a million elements are stored.

TODO: tests up to $10^8$

TODO: explain in more detail when MPCFs take longer to insert and longer to lookup. Check to see how stash size helps or hurts - should make inserts easier and lookups harder.

TODO: write a conclusion. Not sure what to conclude, yet

TODO: compare with cuckoo filters and traditional Bloom filters

%% InsertMPCF(input: U, mpcf: MPCF(U, k)) {
%%   if (Lookup(input, mpcf)) return
%%   hashed := mpcf.HashFunction(input)
%%   InsertSide(hashed[0, k+8), hashed[k+8, k+15),
%%              mpcf.Side[0], mpcf.Side[1])
%% }


%% The primary complexity in combining DySECT and the unnamed structure from \cite{psw} is that different levels of the structure have different sizes, and so the portion of the hashed value that is implicitly stored in the location is different.
%% This is why the fingerprint size can vary across slots.
%% One restriction is that, 



%% To address this, in a minimal plastic cuckoo filter, the key is permited to have a lower size.
%% In larger levels, the key has length $L + z + \lg \nicefrac{1}{\varepsilon}$.
%% In smaller levels, the key may also have length one less than that.
%% Since longer keys can be stored in longer of shorter levels, the values associated with keys in the lnger levels are shorter than the values associated with long keys in the shorter levels.

%% When moving keys between levels, keys may sometime move from shorter to longer keys when moving from a short level to a long level.
%% When this occurs, a bit is stolen from the tail, as described above for plastic filters.
%% This means that sometimes a single key turns into two, as above.
%% During the transition from all-small levels to all-large levels, each key will have a bit moved to it from the value exactly once, since when keys move from long levels to short levels, they can keep the same length.

%% In a DySECT table, there are $2^L$ {\em levels}.
%% Each level has $2^z$ or $2^{z+1}$ buckets.
%% When the table grows, a single level grows from $2^z$ to $2^{z+1}$ buckets.
%% Once all the levels have $2^{z+1}$ buckets, new growth increases one level from $2^{z+1}$ to $2^{z+2}$ buckets, and so on.




%% Each plastic filter consists of a left and a right {\em side}.
%% Each side has $2^L$ {\em layers}.
%% Each layer is an array of {\em buckets}.
%% Each bucket contains $b$ {\em slots}, each of which holds a {\em fingerprint} of length $F$ or $F-1$.
%% In addition to the fingerprint, each slot contains a {\em tail}, which is a binary string of length less than $T$.

%% Both the fingerprint and the tail are encoded by using a single additional bit each.
%% The number of trailing 0 bits in the encoding indicates the length of the tail.
%% For instance, a tail of length $n$ is stored in the high order bits, then one 1-bit is present, then $T - n$ 0-bits.
%% This encoding uses one additional bit each, so the total size of the slot is $F + T + 2$ bits.

%% Corresponding layers in the two sides of an plastic filter have the same size.
%% Every array of buckets has a size that is a power of two.
%% At all points in time, there is a {\em cursor $c$} in $\mathbb{Z}_{2^L}$ and a value $m$ such that all layers at indices greater than or equal to $c$ have bucket arrays of size $m$, while all layers at indices less than $c$ have bucket arrays of size $2m$.
%% All fingerprints in size-$2m$ layers have length $F-1$, whereas fingerprints in size-$m$ layers can also have size $F$.

%% Each side contains two randomly-chosen operators; each operator is a set of permutations; each permutation operates on $\mathbb{Z}_{2^i}$ for each $i < L + F - 1 \le w$, where $w$ is the word size of the machine.
%% %Each operation below is applied to bit lengths of $L + \lg m$ and $L + \lg m + 1$.
%% To find a key from $\mathbb{Z}_{2^k}$ in an plastic filter, it is first broken up into four pieces, starting from the high-order bits.

%% \begin{enumerate}
%% \item The top $L + \lg m + F - 1$ or $L + \lg m + F$ bits
%% \item The next $T$ bits (the tail)
%% \item The remaining bits, which are discarded
%% \end {enumerate}

%% The top bits are hashed with the permutations, and then the results are broken up into three parts:

%% \begin{enumerate}
%% \item The $L$ most significant bits, indicating the layer
%% \item Since the index of the layer has now been set, the length of its bucket array is now known.
%%   If the bucket array has length $2m$, the next $\lg m + 1$ bits are selected as the bucket index.
%%   Otherwise, the next $\lg m$ bits are.
%% \item $F$ or $F - 1$ bits, representing the fingerprint.
%%   If the bucket array has length $2m$ and the top $L + \lg m + F - 1$ bits were selected and hashed, then only $F-2$ bits are left for the fingerprint.
%%   These are considered {\em invalid}.
%% \end{enumerate}

%% The named parts will be referred to as the {\em layer index}, the {\em bucket index}, the {\em fingerprint}, and the {\em tail}.
%% These four parts together constitute a {\em path}; the sum of the bit lengths of the components is a path's length.
%% By their length constraints (at most $L + \lg m + F$ bits), paths never have a layer index less than $c$ and a fingerprint of length $F$.
%% Because permutations have inverses, the path can be used to reconstruct the top $L + \lg m + F - 1 + T$ or $L + \lg m + F + T$ bits of the key, depending on the length of the bucket index and the fingerprint.

%% \subsection{Operations}

%% To look up a key, two to four paths are first formed, corresponding to the two permutations times the two path lengths.
%% It may be the case that the paths produced by hashing a short key are pointing to locations in a large level.
%% Such paths are ignored.
%% A slot in a bucket matches a path when the keys are identical.\footnote{This was the test in \cite{psw}. In minimal plastic cuckoo filters, the values are also matched - the one in the entry must be a prefix of the one being searched for. This lowers the false positive rate at the cost of extra comparison time.}

%% Insertion follows the usual cuckoo pattern of looking for an empty slot and then kicking out a value if none is found, continuing until all keys have been successfully placed.
%% Minimal plastic cuckoo filters additionally have a temporary stash to handle keys that cannot be placed until a level size increase is done.

%% One difference is the keys, as each side uses a permutation and must reconstruct the top bits of the original key before hashing with the permutations from the opposite side of the table.
%% There are three cases to cover:

%% \begin{itemize}
%% \item Kicking the value in a slot from a layer with index $< c$ to one with an index $\ge c$:
%%   the fingerprints in layers $< c$ have length $F-1$, and the bucket indices have length $1 + \lg m$.
%%   To move an item to a layer $\ge c$, move the low-order bit from the bucket index into a new high-order bit in the fingerprint.
%%   This makes a slot with a fingerprint of length $F$, which is permitted in layers with index $\ge c$.
%% \item Kicking the value with a fingerprint of length $F$ to a layer with index $< c$:
%%   this is simply the reverse of the kick above, so a the high order bit from the fingerprint is moved to be a new low-order bit in the bucket index.
%% \item Kicking the value a fingerprint of length $F-1$ from a layer with index $\ge c$ to a layer with index $< c$:
%%   here, again, we steal a high-order bit from the fingerprint to push to the bucket index as a new low-order bit.
%%   This leaves the fingerprint with length $F-2$, which is invalid.
%%   To fix this, we steal a bit from the tail to be in the fingerprint.

%%   Note that, unlike the cases above, the stolen bit is from the un-permuted domain.
%%   As such, that value needs to be sent through the permutation backwards, have the tail bit appended, then re-hashed, potentially changing the layer index.
%%   No matter what the new layer index is, the concatenated bucket index plus fingerprint has length $\lg m + 1$, which is valid.

%%   If there are no remaining bits in the tail, {\em two} values are inserted; each one constructed by appending a bit to the fingerprint before rehashing.
%%   This essentially turns a single slot into two.
%% \end{itemize}

%% When the hash table is close to full, the cuckoo lookup path will grow.
%% Once the hash table occupancy exceeds some pre-set fill-factor $\alpha$, the two bucket arrays at location $c$ (the cursor) are doubled in size, and their old values are inserted into the table with the newly-doubled arrays.
%% Once $c = 2^L$ and the doubling operation is complete, $c$ is reset to $0$ and the operators are swapped.

% TODO: what is the fpp of the dictionary

% TODO: permutation swapping

% TODO: combining tails

% TODO: hashing entropy enough when tail is long and head is short, or do all items in bucket b necessarily map to the same bucket c?

TODO: show that longer fingerprints lead to higher fill factors

%TODO: show phase change of when a filter can be filled with a given size

TODO: Show how much time is spent in upsize

TODO: show how stash limits lead to higher insert times and lower lookup times


\bibliographystyle{alpha}
\bibliography{plastic}

\appendix
\section{MPCF pseudocode}
\label{mpcf-appendix}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
LookupSide(hashed: `$\ints_2^{64}$`, side: `$\ints_2$`, mpcf: MPCF(U, k)) {
  permuted := mpcf.Permutation[side](hashed[0, k+12))
  level_number := permuted[0, 5)
  if (level_number `$\ge$` mpcf.cursor) {
    bucket := mpcf.Level[level_number][permuted[5, k + 5)]
    if (LookupBucket(permuted[k+5, k+12),
                     hashed[k+12, k+18), bucket)) {
      return True
    }
  }
  permuted = mpcf.Permutation[side](hashed[0, k+13))
  level_number = permuted[0, 5)
  level := mpcf.Level[level_number]
  middle := (level_number `$\ge$` mpcf.cursor) then k + 5 else k + 6
  bucket := level[permuted[5, middle)]
  return LookupBucket(permuted[middle, k+13),
                      hashed[k+13, k+19), bucket)
}

MLookup(input: U, mpcf: PCF(U, k)) {
  hashed := mpcf.HashFunction(input)
  for (side : {0, 1}) {
    if (LookupSide(hashed, mpcf.Side[side], mpcf)) return True
  }
  return False
}
\end{lstlisting}
\caption{The lookup operation in an MPCF.}
\end{figure}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
MInsertSide(level_number: `$\ints_{32}$`, bucket_number: `$\ints_2^k \cup \ints_2^{k+1}$`,
            fingerprint `$\ints_2^8 \cup \ints_2^9$`, tail: `$\sum_{i \le 5}\ints_2^i$`, side: `$\ints_2$`,
            mpcf: MPCF(U, k)) {
  bucket := mpcf.Level[level_number][bucket_number]
  new_slot := InsertBucket(fingerprint, tail, bucket)
  if (new_slot == `$\bot$`) return
  fingerprint = new_slot.fingerprint
  tail = new_slot.tail
  permuted := Concat(level_number, bucket_number, fingerprint)
  hashed := mpcf.Permutation[side]`$^{-1}$`(permuted)
  permuted = mpcf.Permutation[1 - side](hashed)
  MInsertPermuted(permuted, tail, side, mpcf)
}

MInsertPermuted(permuted: `$\ints_2^{k+13} \cup \ints_2^{k+14}$`, tail: `$\sum_{i \le 5}\ints_2^i$`, side: `$\ints_2$`,
                mpcf: MPCF(U, k)) {
  level_number := permuted[0, 5)
  if (|permuted| == k + 14) {
    middle := if (level_number `$\ge$` mpcf.cursor) then k+5 else k+6
    MInsertSide(level_number, permuted[5, middle),
                permuted[middle, k+14), tail, 1 - side)
    return
  }
  if (level_number `$\ge$` mpcf.cursor) {
    permuteds := {permuted}
  }
  if (permuted, tail) := steal(permuted, tail) {
    permuteds := {permuted}
  } else {
    (permuted0, permuted1, tail) := steal(permuted, tail)
    permuteds := {permuted0, permuted1})
  }
  for (p : permuteds) {
    MInsertSide(level_number, p[5, k+5), p[k+5, k+13), tail, 1 - side)
  }
}


\end{lstlisting}
\caption{Pseudocode for the insert operation on MPCFs}
\end{figure}


\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
InsertMPCF(key: U, mpcf: MPCF(U, k)) {
  hashed := mpcf.HashFunction(key)
  permuted := mpcf.Permutation[0](hashed[0, k+14))
  level_number := permuted[0, 5)
  middle := if (level_number `$\ge$` mpcf.cursor) then k+5 else k+6
  bucket_number := permuted[5, middle)
  fingerprint := permuted[middle, k+14)
  tail := hashed[k+14, k+19)
  MInsertSide(level_number,  bucket_number, fingerprint, tail, 0)
}
\end{lstlisting}
\caption{Pseudocode for the insert operation on MPCFs}
\end{figure}

\begin{figure}
\begin{lstlisting}[escapeinside={`}{`}]
UpsizeMPCF(key: U, mpcf: MPCF(U, k)) {
  old := mpcf.Level[cursor]
  mpcf.Level[cursor] = new Level(2^{k+1})
  mpcf.cursor = mpcf.cursor + 1
  for (side : {0, 1}) {
    for (bucket_index : `$\ints_2^k$`) {
      for (element : old.MBucket[side][bucket_index]) {
        cursor = cursor - 1
        permuted := Concat(cursor, bucket_index, slot.fingerprint)
        hashed := mpcf.Permutation[side]`$^{-1}$`(permuted)
        cursor = cursor + 1
        permuted = mpcf.Permutation[side](hashed)
        MInsertPermuted(permuted, slot.tail, side, mpcf)

      }
    }
  }
}
\end{lstlisting}
\caption{Pseudocode for the upsize operation on MPCFs}
\end{figure}


\end{document}

%%  LocalWords:  growable lookups quotienting AMQ Upsize PCF PCF's
%%  LocalWords:  HashFunction LookupBucket IsPrefixOf pcf InsertPCF
%%  LocalWords:  InsertSide InsertBucket RandomSlotIn otherSide PCFs
%%  LocalWords:  Concat upsize doublings DySECT MPCF MSlot MBucket
%%  LocalWords:  upsizes TODO fpp LookupSide mpcf MLookup MInsertSide
%%  LocalWords:  MInsertPermuted permuteds MPCFs InsertMPCF MElement
%%  LocalWords:  UpsizeMPCF PBFs
